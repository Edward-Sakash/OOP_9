# Exercise 1 (Polymorphism - Negator):
Write a class called Negator
  use @singlesipatchmethod on the neg method
if you use int  as argument return the negative value of this integer
if you use bool  return the opposite boolean
if you use str return an empty string
class Negator:
    @singledispatchmethod
    def neg(self, arg):
        raise NotImplementedError("Cannot negate a")
......
......
......
obj = Negator()
obj.neg(1) #--> -1
obj.neg(True) #--> False
obj.neg('Hello') #--> ''

# Exercise 2 (Polymorphism - OverloadingII- Math):
- Create a Python class called MathOperations with overloaded methods for:
1. addition (add()),
2. subtraction (subtract()), and
3. multiplication (multiply()).
Each method should take different numbers of arguments and perform the corresponding operation.
In your main() function, create an instance of the MathOperations class and demonstrate the polymorphic behavior by calling each method with different numbers of arguments.

class MathOperations:
    def add(...):
....
....

    def subtract(....):
....
....

    def multiply(....):
....
....

def main():
    math_ops = MathOperations()

    # Addition
    result = math_ops.add(2, 3)
    print(f"Addition Result: {result}")

    result = math_ops.add(4, 6, 8)
    print(f"Addition Result: {result}")

    # Subtraction
    result = math_ops.subtract(10, 3)
    print(f"Subtraction Result: {result}")

    result = math_ops.subtract(20, 5, 3)
    print(f"Subtraction Result: {result}")

    # Multiplication
    result = math_ops.multiply(2, 5)
    print(f"Multiplication Result: {result}")

    result = math_ops.multiply(3, 4, 2)
    print(f"Multiplication Result: {result}")


main()

# Exercise 3 - Singleon Pattern (Version 3):
Complete the following code:
class Singleton:
    _instances = {}

    def __init__(self, class_):
        self._class = class_
        # self._instances = {}

    def __call__(self, *args, **kwargs):
        if self._class not in self._____:
            self._instances[_______] = _________________
        return self._instances[self._______]

@Singleton
class FirstClass:
    def __init__(self, m):
        self.val = m

a = FirstClass(1)
b = FirstClass(23)

a == b #True
research the __ call__ method
fill out the _______ spaces.
make sure that only one instance per class is created

# Exercise 4 (Singleton Logger):

Implement a Singleton class called Logger that keeps track of logs generated by different parts of a system. The Logger class should have the following behavior:
It should maintain a list of log messages.
 It should provide a method called add_log that takes a message as input and adds it to the list of logs.
It should provide a method called get_logs that returns the list of logs.
Your task is to implement the Logger class as a Singleton, ensuring that only one instance of the class can exist.
Hint: You can use the singleton decorator from today's class.

class Logger:
.........
.........

# Testing the Singleton Logger
logger1 = Logger()
logger1.add_log("Log message 1")

logger2 = Logger()
logger2.add_log("Log message 2")

logger3 = Logger()
logger3.add_log("Log message 3")

# All instances of the logger will have the same logs
print(logger1.get_logs())  # Output: ['Log message 1', 'Log message 2', 'Log message 3']
print(logger2.get_logs())  # Output: ['Log message 1', 'Log message 2', 'Log message 3']
print(logger3.get_logs())  # Output: ['Log message 1', 'Log message 2', 'Log message 3']